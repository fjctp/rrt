<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Maze Runner with RRT</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
  <style>
    body {
      margin: 0;
      padding: 10px;
      display: flex;
      flex-direction: column;
      align-items: center;
      background-color: #f5f5f5;
      font-family: Arial, sans-serif;
    }
    .container {
      background: white;
      padding: 15px;
      border-radius: 10px;
      box-shadow: 0 4px 6px rgba(0,0,0,0.1);
      max-width: 100%;
      box-sizing: border-box;
    }
    h1 {
      margin: 0 0 10px 0;
      color: #333;
      font-size: 20px;
    }
    .info {
      margin: 10px 0;
      color: #666;
      font-size: 12px;
    }
    button {
      background-color: #4CAF50;
      color: white;
      border: none;
      padding: 10px 20px;
      font-size: 14px;
      border-radius: 5px;
      cursor: pointer;
      margin: 10px 0;
      width: 100%;
      max-width: 300px;
    }
    button:hover {
      background-color: #45a049;
    }
    #status {
      font-weight: bold;
      color: #333;
      margin: 10px 0;
      font-size: 13px;
    }
    .instructions {
      margin-top: 15px;
      font-size: 12px;
      color: #555;
    }
    .instructions ul {
      margin: 5px 0;
      padding-left: 20px;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Maze Runner with RRT Path Planning</h1>
    <div class="info">Green = Start | Red = Goal | Blue lines = RRT exploration</div>
    <button onclick="generateAndSolve()">Generate & Solve</button>
    <div id="status">Click "Generate & Solve" to start</div>
    <div id="canvas-container"></div>
    <div class="instructions">
      <strong>How RRT works:</strong>
      <ul>
        <li>Randomly samples points in the maze</li>
        <li>Grows a tree from start toward sampled points</li>
        <li>Avoids obstacles (black walls)</li>
        <li>Connects to goal when close enough</li>
      </ul>
    </div>
  </div>

  <script>
    var maze = [];
    var cols, rows;
    var cellSize = 5;
    var start, goal;
    var tree = [];
    var path = [];
    var foundPath = false;
    var maxIterations = 5000;
    var canvasWidth, canvasHeight;
    
    // Node: represents a single vertex in the RRT tree.
    // - x, y: grid coordinates of the node (integers)
    // - parent: reference to the parent Node from which this node was expanded
    // The `parent` reference is used to reconstruct a path from any node
    // back to the start by following parent links (used in `constructPath`).
    class Node {
      constructor(x, y, parent) {
        this.x = x;
        this.y = y;
        this.parent = parent || null;
      }
    }

    // Initialize the p5 canvas and compute grid size based on `cellSize`.
    // Sets the canvas parent element, frame rate, and disables automatic looping
    // until the user generates a maze.
    function setup() {
      var container = document.getElementById('canvas-container');
      canvasWidth = min(windowWidth - 40, 600);
      canvasHeight = min(windowHeight - 300, 500);
      
      var canvas = createCanvas(canvasWidth, canvasHeight);
      canvas.parent('canvas-container');
      cols = floor(width / cellSize);
      rows = floor(height / cellSize);
      frameRate(30);
      noLoop();
    }

    // Handle browser window resize: adjust canvas and recompute grid.
    // If a maze already exists, regenerate and solve it with new dimensions.
    function windowResized() {
      canvasWidth = min(windowWidth - 40, 600);
      canvasHeight = min(windowHeight - 300, 500);
      resizeCanvas(canvasWidth, canvasHeight);
      cols = floor(width / cellSize);
      rows = floor(height / cellSize);
      if (maze.length > 0) {
        generateAndSolve();
      }
    }

    // Main draw loop (p5): renders the maze, the RRT tree, and the path.
    // Also advances the RRT by a few steps per frame if a path has not
    // yet been found and iteration limits are not exceeded.
    function draw() {
      background(240);
      
      if (maze.length > 0) {
        drawMaze();
        drawTree();
        drawPath();
        
        if (!foundPath && tree.length > 0 && tree.length < maxIterations) {
          for (var i = 0; i < 5; i++) {
            rrtStep();
          }
        }
      }
    }

    // UI entry point: generate a new maze and start the animation/solver.
    function generateAndSolve() {
      document.getElementById('status').textContent = 'Generating maze and finding path...';
      generateMaze();
      loop();
    }

    // Create a random grid-based maze (0 = free, 1 = wall), pick start/goal,
    // and reset the RRT tree and path state.
    function generateMaze() {
      maze = [];
      for (var i = 0; i < rows; i++) {
        maze[i] = [];
        for (var j = 0; j < cols; j++) {
          maze[i][j] = random() < 0.3 ? 1 : 0;
        }
      }
      
      start = { x: 1, y: 1 };
      goal = { x: cols - 2, y: rows - 2 };
      maze[start.y][start.x] = 0;
      maze[goal.y][goal.x] = 0;
      
      tree = [new Node(start.x, start.y)];
      path = [];
      foundPath = false;
    }

    // Render the maze grid, the start point (green), and the goal (red).
    function drawMaze() {
      for (var i = 0; i < rows; i++) {
        for (var j = 0; j < cols; j++) {
          if (maze[i][j] === 1) {
            fill(40);
            noStroke();
            rect(j * cellSize, i * cellSize, cellSize, cellSize);
          }
        }
      }
      
      fill(100, 200, 100);
      circle(start.x * cellSize + cellSize/2, start.y * cellSize + cellSize/2, cellSize);
      
      fill(200, 100, 100);
      circle(goal.x * cellSize + cellSize/2, goal.y * cellSize + cellSize/2, cellSize);
    }

    // Draw the RRT tree lines: for each node, draw a line to its parent.
    // The `node.parent` property is a reference to the node from which this
    // node was expanded. If `parent` is null the node is the root.
    function drawTree() {
      stroke(150, 150, 255, 100);
      strokeWeight(3);
      for (var i = 0; i < tree.length; i++) {
        var node = tree[i];
        if (node.parent) {
          line(
            node.x * cellSize + cellSize/2,
            node.y * cellSize + cellSize/2,
            node.parent.x * cellSize + cellSize/2,
            node.parent.y * cellSize + cellSize/2
          );
        }
      }
    }

    // If a final path exists, draw it as a thicker colored line.
    function drawPath() {
      if (path.length > 1) {
        stroke(255, 100, 100);
        strokeWeight(5);
        noFill();
        beginShape();
        for (var i = 0; i < path.length; i++) {
          vertex(path[i].x * cellSize + cellSize/2, path[i].y * cellSize + cellSize/2);
        }
        endShape();
      }
    }

    // Perform one RRT iteration: sample a point, find the nearest tree node,
    // attempt to steer from that node toward the sample, do collision checks,
    // add the new node to the tree, and check if the goal is reached.
    function rrtStep() {
      if (foundPath) return;
      
      var randomPoint = {
        x: floor(random(cols)),
        y: floor(random(rows))
      };
      
      if (random() < 0.1) {
        randomPoint = { x: goal.x, y: goal.y };
      }
      
      var nearest = findNearest(randomPoint);
      var newNode = steer(nearest, randomPoint);
      
      if (newNode && !collisionCheck(nearest, newNode)) {
        tree.push(newNode);
        
        var distToGoal = dist(newNode.x, newNode.y, goal.x, goal.y);
        if (distToGoal < 2) {
          foundPath = true;
          constructPath(newNode);
          document.getElementById('status').textContent = 'Path found!';
        }
      }
      
      if (tree.length >= maxIterations) {
        document.getElementById('status').textContent = 'Max iterations reached. No path found.';
        foundPath = true;
      }
    }

    // Find the nearest node in `tree` to a given `point` using a linear scan.
    // This is a brute-force nearest-neighbor search (O(n)) over all nodes in
    // the tree. For small trees this is simple and fast; for larger trees one
    // could use spatial structures (k-d tree, grid hashing, etc.) to speed up
    // nearest-neighbor queries.
    function findNearest(point) {
      var minDist = Infinity;
      var nearest = tree[0];
      
      for (var i = 0; i < tree.length; i++) {
        var d = dist(tree[i].x, tree[i].y, point.x, point.y);
        if (d < minDist) {
          minDist = d;
          nearest = tree[i];
        }
      }
      return nearest;
    }

    // Move from node `from` towards point `to` by at most `maxStep` grid cells.
    // Returns a new Node positioned one step toward `to` with `from` as parent.
    function steer(from, to) {
      var maxStep = 1;
      var dx = to.x - from.x;
      var dy = to.y - from.y;
      var distance = sqrt(dx * dx + dy * dy);
      
      if (distance === 0) return null;
      
      var stepX = round((dx / distance) * min(maxStep, distance));
      var stepY = round((dy / distance) * min(maxStep, distance));
      
      var newX = from.x + stepX;
      var newY = from.y + stepY;
      
      if (newX >= 0 && newX < cols && newY >= 0 && newY < rows) {
        return new Node(newX, newY, from);
      }
      return null;
    }

    // Check the discrete line from `from` to `to` for walls. Returns true if
    // a collision (wall) is found. Uses simple integer stepping and checks
    // each visited grid cell for occupancy.
    function collisionCheck(from, to) {
      if (maze[to.y][to.x] === 1) return true;
      
      var steps = max(abs(to.x - from.x), abs(to.y - from.y));
      for (var i = 0; i <= steps; i++) {
        var t = steps === 0 ? 0 : i / steps;
        var x = round(from.x + (to.x - from.x) * t);
        var y = round(from.y + (to.y - from.y) * t);
        if (maze[y][x] === 1) return true;
      }
      return false;
    }

    // Construct the path by following `parent` links from `endNode` back to
    // the root/start node. The path array will contain nodes from start->goal.
    function constructPath(endNode) {
      path = [];
      var current = endNode;
      while (current) {
        path.unshift(current);
        current = current.parent;
      }
    }
  </script>
</body>
</html>