<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Maze Runner with RRT</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
  <style>
    body {
      margin: 0;
      padding: 10px;
      display: flex;
      flex-direction: column;
      align-items: center;
      background-color: #f5f5f5;
      font-family: Arial, sans-serif;
    }
    .container {
      background: white;
      padding: 15px;
      border-radius: 10px;
      box-shadow: 0 4px 6px rgba(0,0,0,0.1);
      max-width: 100%;
      box-sizing: border-box;
    }
    h1 {
      margin: 0 0 10px 0;
      color: #333;
      font-size: 20px;
    }
    .info {
      margin: 10px 0;
      color: #666;
      font-size: 12px;
    }
    button {
      background-color: #4CAF50;
      color: white;
      border: none;
      padding: 10px 20px;
      font-size: 14px;
      border-radius: 5px;
      cursor: pointer;
      margin: 10px 0;
      width: 100%;
      max-width: 300px;
    }
    button:hover {
      background-color: #45a049;
    }
    #status {
      font-weight: bold;
      color: #333;
      margin: 10px 0;
      font-size: 13px;
    }
    .instructions {
      margin-top: 15px;
      font-size: 12px;
      color: #555;
    }
    .instructions ul {
      margin: 5px 0;
      padding-left: 20px;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Maze Runner with RRT Path Planning</h1>
    <div class="info">Green = Start | Red = Goal | Blue lines = RRT exploration</div>
    <button onclick="generateAndSolve()">Generate & Solve</button>
    <div id="status">Click "Generate & Solve" to start</div>
    <div id="canvas-container"></div>
    <div class="instructions">
      <strong>How RRT works:</strong>
      <ul>
        <li>Randomly samples points in the maze</li>
        <li>Grows a tree from start toward sampled points</li>
        <li>Avoids obstacles (black walls)</li>
        <li>Connects to goal when close enough</li>
      </ul>
    </div>
  </div>

  <script>
    var maze = [];
    var cols, rows;
    var cellSize = 5;
    var start, goal;
    var tree = [];
    var path = [];
    var foundPath = false;
    var maxIterations = 5000;
    var canvasWidth, canvasHeight;
    var kdRoot = null; // root of the k-d tree spatial index
    var kdInsertsSinceRebuild = 0; // count inserts since last rebuild
    var KD_REBUILD_INTERVAL = 200; // rebuild k-d tree every N inserts
    
    // Node: represents a single vertex in the RRT tree.
    // - x, y: grid coordinates of the node (integers)
    // - parent: reference to the parent Node from which this node was expanded
    // The `parent` reference is used to reconstruct a path from any node
    // back to the start by following parent links (used in `constructPath`).
    class Node {
      constructor(x, y, parent) {
        this.x = x;
        this.y = y;
        this.parent = parent || null;
      }
    }

    // Simple incremental k-d tree implementation for 2D points.
    // We store references to the RRT `Node` objects inside KD nodes so
    // that nearest-neighbor queries return the actual tree node (with parent link).
    function KDNode(node, axis) {
      this.node = node; // reference to RRT Node
      this.left = null;
      this.right = null;
      this.axis = axis; // 0 => x, 1 => y
    }

    // Insert an RRT `Node` into the k-d tree. Returns the (possibly new) root.
    function kdInsert(root, rrtNode, depth) {
      if (!root) return new KDNode(rrtNode, depth % 2);
      var axis = root.axis;
      if ((axis === 0 && rrtNode.x < root.node.x) || (axis === 1 && rrtNode.y < root.node.y)) {
        root.left = kdInsert(root.left, rrtNode, depth + 1);
      } else {
        root.right = kdInsert(root.right, rrtNode, depth + 1);
      }
      return root;
    }

    // Wrapper that returns the nearest RRT Node in the k-d tree to `point`.
    function kdNearestSearch(root, point) {
      if (!root) return null;
      var best = { node: null, dist: Infinity };

      function sqDist(a, b) {
        var dx = a.x - b.x;
        var dy = a.y - b.y;
        return dx * dx + dy * dy;
      }

      function recurse(curr) {
        if (!curr) return;
        var d = sqDist(curr.node, point);
        if (d < best.dist) {
          best.node = curr.node;
          best.dist = d;
        }

        var axis = curr.axis;
        var diff = (axis === 0) ? (point.x - curr.node.x) : (point.y - curr.node.y);

        var first = diff < 0 ? curr.left : curr.right;
        var second = diff < 0 ? curr.right : curr.left;

        recurse(first);
        if (diff * diff < best.dist) recurse(second);
      }

      recurse(root);
      return best.node;
    }

    // Build a balanced k-d tree from an array of RRT Node objects.
    // This does a median split at each recursion level and results in a
    // reasonably balanced tree (O(n log n) build).
    function buildKDFromArray(nodes, depth) {
      if (!nodes || nodes.length === 0) return null;
      var axis = depth % 2;
      // sort copy by axis
      var arr = nodes.slice();
      arr.sort(function(a, b) {
        return axis === 0 ? a.x - b.x : a.y - b.y;
      });
      var mid = Math.floor(arr.length / 2);
      var root = new KDNode(arr[mid], axis);
      root.left = buildKDFromArray(arr.slice(0, mid), depth + 1);
      root.right = buildKDFromArray(arr.slice(mid + 1), depth + 1);
      return root;
    }

    // Rebuild the kd-tree from the full `tree` array and reset the insert counter.
    function rebuildKD() {
      kdRoot = buildKDFromArray(tree.slice(), 0);
      kdInsertsSinceRebuild = 0;
    }

    // Initialize the p5 canvas and compute grid size based on `cellSize`.
    // Sets the canvas parent element, frame rate, and disables automatic looping
    // until the user generates a maze.
    function setup() {
      var container = document.getElementById('canvas-container');
      canvasWidth = min(windowWidth - 40, 600);
      canvasHeight = min(windowHeight - 300, 500);
      
      var canvas = createCanvas(canvasWidth, canvasHeight);
      canvas.parent('canvas-container');
      cols = floor(width / cellSize);
      rows = floor(height / cellSize);
      frameRate(30);
      noLoop();
    }

    // Handle browser window resize: adjust canvas and recompute grid.
    // If a maze already exists, regenerate and solve it with new dimensions.
    function windowResized() {
      canvasWidth = min(windowWidth - 40, 600);
      canvasHeight = min(windowHeight - 300, 500);
      resizeCanvas(canvasWidth, canvasHeight);
      cols = floor(width / cellSize);
      rows = floor(height / cellSize);
      if (maze.length > 0) {
        generateAndSolve();
      }
    }

    // Main draw loop (p5): renders the maze, the RRT tree, and the path.
    // Also advances the RRT by a few steps per frame if a path has not
    // yet been found and iteration limits are not exceeded.
    function draw() {
      background(240);
      
      if (maze.length > 0) {
        drawMaze();
        drawTree();
        drawPath();
        
        if (!foundPath && tree.length > 0 && tree.length < maxIterations) {
          for (var i = 0; i < 5; i++) {
            rrtStep();
          }
        }
      }
    }

    // UI entry point: generate a new maze and start the animation/solver.
    function generateAndSolve() {
      document.getElementById('status').textContent = 'Generating maze and finding path...';
      generateMaze();
      loop();
    }

    // Create a random grid-based maze (0 = free, 1 = wall), pick start/goal,
    // and reset the RRT tree and path state.
    function generateMaze() {
      maze = [];
      for (var i = 0; i < rows; i++) {
        maze[i] = [];
        for (var j = 0; j < cols; j++) {
          maze[i][j] = random() < 0.3 ? 1 : 0;
        }
      }
      
      start = { x: 1, y: 1 };
      goal = { x: cols - 2, y: rows - 2 };
      maze[start.y][start.x] = 0;
      maze[goal.y][goal.x] = 0;
      
      tree = [new Node(start.x, start.y)];
      // initialize k-d tree with a balanced build from the current tree
      kdInsertsSinceRebuild = 0;
      rebuildKD();
      path = [];
      foundPath = false;
    }

    // Render the maze grid, the start point (green), and the goal (red).
    function drawMaze() {
      for (var i = 0; i < rows; i++) {
        for (var j = 0; j < cols; j++) {
          if (maze[i][j] === 1) {
            fill(40);
            noStroke();
            rect(j * cellSize, i * cellSize, cellSize, cellSize);
          }
        }
      }
      
      fill(100, 200, 100);
      circle(start.x * cellSize + cellSize/2, start.y * cellSize + cellSize/2, cellSize);
      
      fill(200, 100, 100);
      circle(goal.x * cellSize + cellSize/2, goal.y * cellSize + cellSize/2, cellSize);
    }

    // Draw the RRT tree lines: for each node, draw a line to its parent.
    // The `node.parent` property is a reference to the node from which this
    // node was expanded. If `parent` is null the node is the root.
    function drawTree() {
      stroke(150, 150, 255, 100);
      strokeWeight(3);
      for (var i = 0; i < tree.length; i++) {
        var node = tree[i];
        if (node.parent) {
          line(
            node.x * cellSize + cellSize/2,
            node.y * cellSize + cellSize/2,
            node.parent.x * cellSize + cellSize/2,
            node.parent.y * cellSize + cellSize/2
          );
        }
      }
    }

    // If a final path exists, draw it as a thicker colored line.
    function drawPath() {
      if (path.length > 1) {
        stroke(255, 100, 100);
        strokeWeight(5);
        noFill();
        beginShape();
        for (var i = 0; i < path.length; i++) {
          vertex(path[i].x * cellSize + cellSize/2, path[i].y * cellSize + cellSize/2);
        }
        endShape();
      }
    }

    // Perform one RRT iteration: sample a point, find the nearest tree node,
    // attempt to steer from that node toward the sample, do collision checks,
    // add the new node to the tree, and check if the goal is reached.
    function rrtStep() {
      if (foundPath) return;
      
      var randomPoint = {
        x: floor(random(cols)),
        y: floor(random(rows))
      };
      
      if (random() < 0.1) {
        randomPoint = { x: goal.x, y: goal.y };
      }
      
      var nearest = findNearest(randomPoint);
      var newNode = steer(nearest, randomPoint);
      
      if (newNode && !collisionCheck(nearest, newNode)) {
        tree.push(newNode);
        // also insert the new node into the k-d tree for faster NN queries
        kdRoot = kdInsert(kdRoot, newNode, 0);
        kdInsertsSinceRebuild++;
        // Periodically rebuild the kd-tree into a balanced structure to
        // avoid long-term degeneration from many incremental inserts.
        if (kdInsertsSinceRebuild >= KD_REBUILD_INTERVAL) {
          rebuildKD();
        }
        
        var distToGoal = dist(newNode.x, newNode.y, goal.x, goal.y);
        if (distToGoal < 2) {
          foundPath = true;
          constructPath(newNode);
          document.getElementById('status').textContent = 'Path found!';
        }
      }
      
      if (tree.length >= maxIterations) {
        document.getElementById('status').textContent = 'Max iterations reached. No path found.';
        foundPath = true;
      }
    }

    // Find the nearest node to `point` using the k-d tree for fast NN queries.
    // The kd-tree is initialized in `generateMaze` and updated on each insert.
    // If the k-d tree is missing or its search fails we fall back to the
    // original brute-force linear scan over `tree` (guaranteed to return a node).
    function findNearest(point) {
      if (kdRoot) {
        var nearest = kdNearestSearch(kdRoot, point);
        if (nearest) return nearest;
      }

      // Brute-force fallback: scan all nodes in `tree` and pick the closest.
      var minDist = Infinity;
      var nearestLinear = tree[0];
      for (var i = 0; i < tree.length; i++) {
        var d = dist(tree[i].x, tree[i].y, point.x, point.y);
        if (d < minDist) {
          minDist = d;
          nearestLinear = tree[i];
        }
      }
      return nearestLinear;
    }

    // Move from node `from` towards point `to` by at most `maxStep` grid cells.
    // Returns a new Node positioned one step toward `to` with `from` as parent.
    function steer(from, to) {
      var maxStep = 1;
      var dx = to.x - from.x;
      var dy = to.y - from.y;
      var distance = sqrt(dx * dx + dy * dy);
      
      if (distance === 0) return null;
      
      var stepX = round((dx / distance) * min(maxStep, distance));
      var stepY = round((dy / distance) * min(maxStep, distance));
      
      var newX = from.x + stepX;
      var newY = from.y + stepY;
      
      if (newX >= 0 && newX < cols && newY >= 0 && newY < rows) {
        return new Node(newX, newY, from);
      }
      return null;
    }

    // Check the discrete line from `from` to `to` for walls. Returns true if
    // a collision (wall) is found. Uses simple integer stepping and checks
    // each visited grid cell for occupancy.
    function collisionCheck(from, to) {
      if (maze[to.y][to.x] === 1) return true;
      
      var steps = max(abs(to.x - from.x), abs(to.y - from.y));
      for (var i = 0; i <= steps; i++) {
        var t = steps === 0 ? 0 : i / steps;
        var x = round(from.x + (to.x - from.x) * t);
        var y = round(from.y + (to.y - from.y) * t);
        if (maze[y][x] === 1) return true;
      }
      return false;
    }

    // Construct the path by following `parent` links from `endNode` back to
    // the root/start node. The path array will contain nodes from start->goal.
    function constructPath(endNode) {
      path = [];
      var current = endNode;
      while (current) {
        path.unshift(current);
        current = current.parent;
      }
    }
  </script>
</body>
</html>