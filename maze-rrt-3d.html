<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>3D Maze Runner with RRT</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: Arial, sans-serif;
      overflow: hidden;
      background: linear-gradient(to bottom, #1a1a2e, #16213e);
    }
    #container {
      width: 100vw;
      height: 100vh;
      position: relative;
    }
    #controls {
      position: absolute;
      top: 20px;
      left: 20px;
      background: rgba(255, 255, 255, 0.95);
      padding: 15px;
      border-radius: 10px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
      z-index: 100;
      max-width: 300px;
    }
    h1 {
      margin: 0 0 10px 0;
      font-size: 18px;
      color: #333;
    }
    .info {
      font-size: 12px;
      color: #666;
      margin: 8px 0;
    }
    button {
      background-color: #4CAF50;
      color: white;
      border: none;
      padding: 10px 20px;
      font-size: 14px;
      border-radius: 5px;
      cursor: pointer;
      margin: 5px 0;
      width: 100%;
    }
    button:hover {
      background-color: #45a049;
    }
    #status {
      font-weight: bold;
      color: #333;
      margin: 10px 0;
      font-size: 13px;
    }
    .legend {
      font-size: 11px;
      color: #555;
      margin-top: 10px;
      line-height: 1.6;
    }
    .color-box {
      display: inline-block;
      width: 12px;
      height: 12px;
      margin-right: 5px;
      vertical-align: middle;
      border: 1px solid #999;
    }
  </style>
</head>
<body>
  <div id="container"></div>
  <div id="controls">
    <h1>3D RRT Path Planning</h1>
    <button onclick="generateAndSolve()">Generate & Solve</button>
    <div id="status">Click "Generate & Solve" to start</div>
    <div class="info">Drag to rotate â€¢ Scroll to zoom</div>
    <div class="legend">
      <div><span class="color-box" style="background: #4CAF50;"></span>Start</div>
      <div><span class="color-box" style="background: #f44336;"></span>Goal</div>
      <div><span class="color-box" style="background: #444;"></span>Obstacles</div>
      <div><span class="color-box" style="background: #64B5F6;"></span>RRT Tree</div>
      <div><span class="color-box" style="background: #FF6B6B;"></span>Final Path</div>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    let scene, camera, renderer;
    let obstacles = [];
    let tree = [];
    let path = [];
    let foundPath = false;
    let start, goal;
    let maxIterations = 3000;
    let treeLines, pathLine;
    let controls;
    
    const GRID_SIZE = 50;
    const CELL_SIZE = 1;
    const NUM_OBSTACLES = 100;
    
    class Node3D {
      constructor(x, y, z, parent = null) {
        this.x = x;
        this.y = y;
        this.z = z;
        this.parent = parent;
      }
    }
    
    // Simple orbit controls
    class SimpleControls {
      constructor(camera, domElement) {
        this.camera = camera;
        this.domElement = domElement;
        this.isDown = false;
        this.prevX = 0;
        this.prevY = 0;
        this.rotX = 0;
        this.rotY = 0;
        
        domElement.addEventListener('mousedown', (e) => {
          this.isDown = true;
          this.prevX = e.clientX;
          this.prevY = e.clientY;
        });
        
        domElement.addEventListener('mousemove', (e) => {
          if (!this.isDown) return;
          const dx = e.clientX - this.prevX;
          const dy = e.clientY - this.prevY;
          this.rotY += dx * 0.005;
          this.rotX += dy * 0.005;
          this.rotX = Math.max(-Math.PI/2, Math.min(Math.PI/2, this.rotX));
          this.prevX = e.clientX;
          this.prevY = e.clientY;
          this.update();
        });
        
        domElement.addEventListener('mouseup', () => {
          this.isDown = false;
        });
        
        domElement.addEventListener('wheel', (e) => {
          e.preventDefault();
          const dist = this.camera.position.length();
          const newDist = dist + e.deltaY * 0.01;
          const scale = Math.max(15, Math.min(50, newDist)) / dist;
          this.camera.position.multiplyScalar(scale);
        });
        
        // Touch support
        domElement.addEventListener('touchstart', (e) => {
          if (e.touches.length === 1) {
            this.isDown = true;
            this.prevX = e.touches[0].clientX;
            this.prevY = e.touches[0].clientY;
          }
        });
        
        domElement.addEventListener('touchmove', (e) => {
          if (!this.isDown || e.touches.length !== 1) return;
          const dx = e.touches[0].clientX - this.prevX;
          const dy = e.touches[0].clientY - this.prevY;
          this.rotY += dx * 0.005;
          this.rotX += dy * 0.005;
          this.rotX = Math.max(-Math.PI/2, Math.min(Math.PI/2, this.rotX));
          this.prevX = e.touches[0].clientX;
          this.prevY = e.touches[0].clientY;
          this.update();
        });
        
        domElement.addEventListener('touchend', () => {
          this.isDown = false;
        });
      }
      
      update() {
        const r = 30;
        this.camera.position.x = r * Math.cos(this.rotX) * Math.sin(this.rotY);
        this.camera.position.y = r * Math.sin(this.rotX);
        this.camera.position.z = r * Math.cos(this.rotX) * Math.cos(this.rotY);
        this.camera.lookAt(0, 0, 0);
      }
    }

    function init() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x0a0a1a);
      
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(25, 15, 25);
      camera.lookAt(0, 0, 0);
      
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.getElementById('container').appendChild(renderer.domElement);
      
      controls = new SimpleControls(camera, renderer.domElement);
      
      // Lighting
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
      scene.add(ambientLight);
      
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(10, 20, 10);
      scene.add(directionalLight);
      
      // Grid helper
      const gridHelper = new THREE.GridHelper(GRID_SIZE, GRID_SIZE, 0x444444, 0x222222);
      gridHelper.position.y = -GRID_SIZE / 2;
      scene.add(gridHelper);
      
      window.addEventListener('resize', onWindowResize);
      
      animate();
    }
    
    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }
    
    function generateAndSolve() {
      document.getElementById('status').textContent = 'Generating 3D maze...';
      clearScene();
      generateObstacles();
      initRRT();
      foundPath = false;
      setTimeout(runRRT, 100);
    }
    
    function clearScene() {
      obstacles.forEach(obs => scene.remove(obs));
      obstacles = [];
      if (treeLines) scene.remove(treeLines);
      if (pathLine) scene.remove(pathLine);
      tree = [];
      path = [];
    }
    
    function generateObstacles() {
      for (let i = 0; i < NUM_OBSTACLES; i++) {
        const size = Math.random() * 2 + 1;
        const geometry = new THREE.BoxGeometry(size, size, size);
        const material = new THREE.MeshStandardMaterial({ 
          color: 0x333333,
          roughness: 0.7,
          metalness: 0.3
        });
        const cube = new THREE.Mesh(geometry, material);
        
        cube.position.x = (Math.random() - 0.5) * (GRID_SIZE - 4);
        cube.position.y = (Math.random() - 0.5) * (GRID_SIZE - 4);
        cube.position.z = (Math.random() - 0.5) * (GRID_SIZE - 4);
        
        cube.userData = { size: size };
        obstacles.push(cube);
        scene.add(cube);
      }
      
      // Add start marker
      const startGeo = new THREE.SphereGeometry(0.5, 16, 16);
      const startMat = new THREE.MeshStandardMaterial({ color: 0x4CAF50 });
      const startMesh = new THREE.Mesh(startGeo, startMat);
      start = { x: -8, y: -8, z: -8 };
      startMesh.position.set(start.x, start.y, start.z);
      scene.add(startMesh);
      obstacles.push(startMesh);
      
      // Add goal marker
      const goalGeo = new THREE.SphereGeometry(0.5, 16, 16);
      const goalMat = new THREE.MeshStandardMaterial({ color: 0xf44336 });
      const goalMesh = new THREE.Mesh(goalGeo, goalMat);
      goal = { x: 8, y: 8, z: 8 };
      goalMesh.position.set(goal.x, goal.y, goal.z);
      scene.add(goalMesh);
      obstacles.push(goalMesh);
    }
    
    function initRRT() {
      tree = [new Node3D(start.x, start.y, start.z)];
      const geometry = new THREE.BufferGeometry();
      const material = new THREE.LineBasicMaterial({ 
        color: 0x64B5F6, 
        transparent: true, 
        opacity: 0.6 
      });
      treeLines = new THREE.LineSegments(geometry, material);
      scene.add(treeLines);
    }
    
    function runRRT() {
      if (foundPath || tree.length >= maxIterations) {
        if (!foundPath) {
          document.getElementById('status').textContent = 'No path found. Try again!';
        }
        return;
      }
      
      for (let i = 0; i < 10; i++) {
        rrtStep();
      }
      
      updateTreeVisualization();
      
      if (!foundPath) {
        requestAnimationFrame(runRRT);
      }
    }
    
    function rrtStep() {
      if (foundPath) return;
      
      let randomPoint = {
        x: (Math.random() - 0.5) * GRID_SIZE,
        y: (Math.random() - 0.5) * GRID_SIZE,
        z: (Math.random() - 0.5) * GRID_SIZE
      };
      
      if (Math.random() < 0.1) {
        randomPoint = { x: goal.x, y: goal.y, z: goal.z };
      }
      
      const nearest = findNearest3D(randomPoint);
      const newNode = steer3D(nearest, randomPoint);
      
      if (newNode && !collisionCheck3D(nearest, newNode)) {
        tree.push(newNode);
        
        const distToGoal = distance3D(newNode, goal);
        if (distToGoal < 1.5) {
          foundPath = true;
          constructPath3D(newNode);
          document.getElementById('status').textContent = 'Path found!';
          updatePathVisualization();
        }
      }
    }
    
    function findNearest3D(point) {
      let minDist = Infinity;
      let nearest = tree[0];
      
      for (let node of tree) {
        const d = distance3D(node, point);
        if (d < minDist) {
          minDist = d;
          nearest = node;
        }
      }
      return nearest;
    }
    
    function distance3D(a, b) {
      const dx = a.x - b.x;
      const dy = a.y - b.y;
      const dz = a.z - b.z;
      return Math.sqrt(dx * dx + dy * dy + dz * dz);
    }
    
    function steer3D(from, to) {
      const maxStep = 1.5;
      const dx = to.x - from.x;
      const dy = to.y - from.y;
      const dz = to.z - from.z;
      const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
      
      if (dist === 0) return null;
      
      const step = Math.min(maxStep, dist);
      const newX = from.x + (dx / dist) * step;
      const newY = from.y + (dy / dist) * step;
      const newZ = from.z + (dz / dist) * step;
      
      if (Math.abs(newX) < GRID_SIZE/2 && Math.abs(newY) < GRID_SIZE/2 && Math.abs(newZ) < GRID_SIZE/2) {
        return new Node3D(newX, newY, newZ, from);
      }
      return null;
    }
    
    function collisionCheck3D(from, to) {
      for (let obstacle of obstacles) {
        if (!obstacle.geometry.type.includes('Box')) continue;
        
        const size = obstacle.userData.size / 2;
        const pos = obstacle.position;
        
        const steps = 10;
        for (let i = 0; i <= steps; i++) {
          const t = i / steps;
          const x = from.x + (to.x - from.x) * t;
          const y = from.y + (to.y - from.y) * t;
          const z = from.z + (to.z - from.z) * t;
          
          if (Math.abs(x - pos.x) < size + 0.3 &&
              Math.abs(y - pos.y) < size + 0.3 &&
              Math.abs(z - pos.z) < size + 0.3) {
            return true;
          }
        }
      }
      return false;
    }
    
    function constructPath3D(endNode) {
      path = [];
      let current = endNode;
      while (current) {
        path.unshift(current);
        current = current.parent;
      }
    }
    
    function updateTreeVisualization() {
      const positions = [];
      for (let node of tree) {
        if (node.parent) {
          positions.push(node.parent.x, node.parent.y, node.parent.z);
          positions.push(node.x, node.y, node.z);
        }
      }
      treeLines.geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
    }
    
    function updatePathVisualization() {
      if (pathLine) scene.remove(pathLine);
      
      const positions = [];
      for (let node of path) {
        positions.push(node.x, node.y, node.z);
      }
      
      const geometry = new THREE.BufferGeometry();
      geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
      const material = new THREE.LineBasicMaterial({ 
        color: 0xFF6B6B, 
        linewidth: 3 
      });
      pathLine = new THREE.Line(geometry, material);
      scene.add(pathLine);
    }
    
    function animate() {
      requestAnimationFrame(animate);
      renderer.render(scene, camera);
    }
    
    init();
  </script>
</body>
</html>